/*
Copyright (c) AppDynamics, Inc., and its affiliates
2015
All Rights Reserved
 */
'use strict';


function RedisProbe(agent) {
  this.agent = agent;

  this.packages = ['redis'];
}
exports.RedisProbe = RedisProbe;



RedisProbe.prototype.attach = function(obj) {
  var self = this;

  if(obj.__appdynamicsProbeAttached__) return;
  obj.__appdynamicsProbeAttached__ = true;
  self.agent.on('destroy', function() {
    if(obj.__appdynamicsProbeAttached__) {
      delete obj.__appdynamicsProbeAttached__;
      proxy.release(obj.createClient);
    }
  });

  var proxy = self.agent.proxy;
  var profiler = self.agent.profiler;

  function proxyCommand(client) {
    var method = client.internal_send_command
      ? "internal_send_command"
      : "send_command";
    proxy.before(client, method, function(obj, args) {
      var time = profiler.time();
      var address = client.address || (client.host + ':' + client.port);
      var command, params;

      if (typeof(args[0]) == 'string') {
        command = args[0];
        params = args[1];
      } else {
        command = args[0].command;
        params = args[0].args;
      }

      var supportedProperties = {
        'SERVER POOL': address,
        'VENDOR': 'REDIS'
      };

      var exitCall = profiler.createExitCall(time, {
        exitType: 'EXIT_CACHE',
        backendName: 'Redis',
        supportedProperties: supportedProperties,
        command: command,
        commandArgs: profiler.sanitize(params),
        stackTrace: profiler.stackTrace()
      });

      function complete(obj, args) {
        if(!time.done()) return;

        if (exitCall) {
          var error = proxy.getErrorObject(args);
          profiler.addExitCall(time, exitCall, error);
        }
      }

      var hasCallback;
      if (typeof(args[0]) === 'object' && typeof(args[0].callback) === 'function') {
        hasCallback = true;
        proxy.before(args[0], 'callback', complete);
      } else if (typeof(args[2]) === 'function') {
        hasCallback = true;
        proxy.before(args, 2, complete);
      } else {
        hasCallback = proxy.callback(args[1], -1, complete, undefined, false);
      }

      if(exitCall && !hasCallback) {
        if(time.done()) {
          profiler.addExitCall(time, exitCall);
        }
      }
    }, false);
  }


  proxy.after(obj, 'createClient', function(obj, args, ret) {
    var client = ret;

    proxyCommand(client);
  });
};
