/*
Copyright (c) AppDynamics, Inc., and its affiliates
2015
All Rights Reserved
 */
'use strict';

function HttpEntryProbe(agent) {
  this.agent = agent;

  this.statusCodesConfig = undefined;
  this.delayedCallbackQueue = [];
}

exports.HttpEntryProbe = HttpEntryProbe;

HttpEntryProbe.prototype.init = function() {
  var self = this;

  self.agent.on('configUpdated', function() {
    self.statusCodesConfig = self.agent.configManager.getConfigValue('errorConfig.httpStatusCodes');
  });
};

HttpEntryProbe.prototype.attach = function(obj, moduleName) {
  var self = this;

  self.agent.timers.startTimer(100, true, function() {
    var now = Date.now();

    while(self.delayedCallbackQueue.length > 0) {
      if(self.delayedCallbackQueue[0].ts < now - 10) {
        var delayedCallbackInfo = self.delayedCallbackQueue.shift();
        delayedCallbackInfo.func.call(this);
      } else {
        break;
      }
    }
  });

  self.isHTTPs = obj.Agent && (obj.Agent.prototype.defaultPort == 443);

  // server probe
  self.agent.proxy.before(obj.Server.prototype, ['on', 'addListener'], function(obj, args) {
    if(args[0] !== 'request') return;

    if(obj.__httpProbe__) return;
    obj.__httpProbe__ = true;

    var cbIndex = args.length -1 ;

    args[cbIndex] = self.__createRequestHandler(args[cbIndex], moduleName === 'https');
  });
};

HttpEntryProbe.prototype.finalizeTransaction = function(err, profiler, time, transaction, res, resEndArgs) {
  if(!time.done()) return;

  transaction.error = transaction.error || res.error || err;
  transaction.statusCode = transaction.statusCode ||
    (transaction.error && transaction.error.statusCode) ||
    (res && res.statusCode) ||
    500;
  transaction.stackTrace = transaction.stackTrace || profiler.formatStackTrace(transaction.error);

  if (!transaction.error) {
    var statusCodeConfig = this.getHttpStatusCodeConfig(transaction.statusCode);
    if (statusCodeConfig) {
      if (statusCodeConfig.enabled) {
        transaction.error = {message: statusCodeConfig.description.toString(), name: "Error"};
      }
    }
    else if ((transaction.statusCode < 200) || (transaction.statusCode >= 400)) {
      var contentType = res.getHeader && res.getHeader("content-type");
      var errorMessage = "HTTP error code : " + transaction.statusCode;
      if (resEndArgs && contentType && contentType.indexOf("utf-8") > -1) {
        transaction.error = {message: errorMessage, name: resEndArgs[0].toString("utf8") + " : " + transaction.statusCode};
      } else {
        transaction.error = {message: errorMessage, name: "HTTP Error Code : " + transaction.statusCode};
      }
    }
  }

  profiler.endTransaction(time, transaction);
};

HttpEntryProbe.prototype.getHttpStatusCodeConfig = function(statusCode) {
  if (!this.statusCodesConfig) {
    return undefined;
  }

  for (var i = 0, length = this.statusCodesConfig.length; i < length; ++i) {
    var statusCodeConfig = this.statusCodesConfig[i];
    if (statusCode >= statusCodeConfig.lowerBound &&
        statusCode <= statusCodeConfig.upperBound) {
      return statusCodeConfig;
    }
  }

  return undefined;
};

function createBTCallback(agent, profiler, time, transaction, req, res, thread, callback, self, origSelf, origArgs) {
  var didRun = false;
  var threadId = thread.current();

  // Node 0.8: need to ensure request isn't consumed
  // before delayed handler gets run
  if (agent.processInfo.isv0_8) {
    req.pause();
  }

  return function () {
    if (didRun) return;
    didRun = true;

    // Node 0.8: safe to resume the request now
    // we're ready to process it
    if (agent.processInfo.isv0_8) {
      req.resume();
    }

    var oldThreadId = thread.current();
    thread.resume(threadId);
    try {
      callback = agent.proxy.wrapWithThreadProxyIfEnabled(callback);
      callback.apply(origSelf, origArgs);
    } catch (e) {
      self.finalizeTransaction(e, profiler, time, transaction, res);
      throw e;
    } finally {
      thread.resume(oldThreadId);
    }
  };
}

HttpEntryProbe.prototype.__createRequestHandler = function (callback, isHTTPs) {
  var self = this;

  return function (req, res) {
    var profiler = self.agent.profiler;
    var proxy = self.agent.proxy;
    var time = profiler.time(true);

    self.agent.metricsManager.addMetric(self.agent.metricsManager.HTTP_INCOMING_COUNT, 1);

    var transaction = profiler.startTransaction(time, req, 'NODEJS_WEB');
    req.__appdThreadId = transaction.threadId;

    transaction.url = req.url;
    transaction.method = req.method;
    transaction.requestHeaders = req.headers;

    var eumEnabled = (transaction.eumEnabled && !transaction.skip) || (self.agent.eum.enabled && self.agent.eum.enabledForTransaction(req));

    if(!transaction.corrHeader && eumEnabled) {
      proxy.before(res, 'writeHead', function(obj) {
        var eumCookie = self.agent.eum.newEumCookie(transaction, req, obj, isHTTPs);
        eumCookie.build();
      });
    }

    proxy.after(res, 'end', function(obj, args) {
      self.finalizeTransaction(null, profiler, time, transaction, res, args);
    });

    if (self.agent.opts.btEntryPointDelayDisabled) {
      try {
        return callback.apply(this, arguments);
      } catch (e) {
        self.finalizeTransaction(e, profiler, time, transaction, res);
        throw e;
      }
    }

    var delayedCallback = createBTCallback(self.agent,
                                           profiler,
                                           time,
                                           transaction,
                                           req, res,
                                           self.agent.thread,
                                           callback,
                                           self,
                                           this,
                                           arguments);

    transaction.once('ignoreTransactionCbExecute', delayedCallback);
    transaction.emit('delayedCallbackReady');
    transaction.once('btInfoResponse', delayedCallback);
    self.delayedCallbackQueue.push({ts: Date.now(), func: delayedCallback});
  };
};

